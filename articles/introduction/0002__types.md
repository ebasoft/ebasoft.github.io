# Int, float, double и прочий зоопарк
> [Пацанская прога](https://t.me/+osWqEEfNA5Y2ZWYy), 29 марта 2023 

Язык C обладает __строгой статической типизацией__. Чего блять? Поясняю. Если уважаемый читатель знаком с 
Python, то разговоры о типах данных могут вызвать кровотечение из глаз и грыжу межушного ганглия. Однако 
типы данных - важная тема и даже в пресловутом питоне они присутствуют. Разберем по запчастям первое 
предложение статьи. 

## Строгая

Вообще уже после первой статьи можно было заметить, что в C необходимо указывать типы данных везде, где 
только можно. Нельзя просто так назвать переменную и забить хуй на ее содержимое. Причем если указал, что 
переменная будет иметь тип `int`, например, изволь совать в неё сугубо целые числа. Сунешь что-то другое - 
как минимум получишь предупреждение от компилятора, как максимум - наебнешь всю прогу максимально 
неочевидным и ебанутым образом. Так вот в этом и заключается строгость типизации. Нельзя на полпути 
переобуться в прыжке и сказать, что ранее целочисленная переменная будет теперь хранить числа с плавающей 
точкой. 

## Статическая

Тут все несколько проще - типы нужно объявлять заранее, то есть прямо рядом с объявлением переменной. С 
одной стороны это вызывает массу негодования у питонистов и прочих интересных личностей, но с другой 
стороны - лажа с преобразованием мочи в говно всплывет еще до запуска программы, в то время как без 
такой типизации разработчик будет часами ломать голову и думать, как так вышло, что в бургере вместо 
котлеты лежит говно. 

![Sample text](memes/types_1.jpg "Ловким движением руки кладем `float` в переменную типа `int`")

## К сути

Всё это конечно очень наглядно и познавательно, но на деле нужно понимать, что строгая типизация - добро, но 
нужно уметь грамотно этим добром пользоваться. В том числе и понимать, что такое данные для компъютера, 
почему с ними постоянно приходится ебаться и что это за заклинание такое - "переполнение инта". Собственно 
начнем с основ всех основ. 

### Устройство памяти

При создании устройств хранения данных возник ряд сложностей - как создать микросхему, которая волшебным 
образом сможет запомнить число 17? Или строку "хуй говно"? Во времена динозавров компы были основаны на лампах, 
об этих темных временах даже говорить не будем. Сейчас внутри мозга компъютера лежат полупроводники, собственно 
из них и изготовлены запоминающие устройства. А в центре всего лежит т.н. ячейка памяти. Она способна 
запоминать свое состояние и оставаться в нем. Однако состояний всего два - условный ВКЛ и условный ВЫКЛ. Они же 
1 и 0. Такая ячейка памяти хранит всего 1 бит информации. И тут, _внезапно_, на помощь приходит двоичная 
система счисления (попробуйте вспомнить с уроков информатики в школе). В двоичной системе можно в целом 
представить любое число. Например число 19 в двоичном виде будет иметь вид 10011. Ставим пять ячеек памяти и 
можем спокойно запомнить это число. А что делать с числом 33? В двоичном виде оно имеет вид 100001. Тут 
понадобится уже шесть ячеек памяти. 

Исторически сложилось, что группу из восьми ячеек памяти (8 бит) называют одним байтом. Каждый бит может 
принимать значение 1 или 0. Таким образом, исходя из простейшей комбинаторики, можно понять, что существует 
2⁸ = 256 различных комбинаций нулей и единиц. То есть в один байт можно впихнуть числа от 0 (00000000) до 
255 (11111111). Однако число 256 впихнуть уже не получится, так как в двоичном виде оно состоит из 9 знаков 
(100000000). На практике при попытке впихнуть невпихуемое мы просто отбрасываем лишние данные (в данном случае 
единичку в самом начале). Поэтому при попытке положить в 1 байт число 256 мы заполним все 8 бит нулями, а единичку 
просрем. При обратном преобразовании, как несложно догадаться, мы получим число 0. Такая ситуация называется 
переполнением - мы по сути теряем часть информации о числе и найти ее уже нигде не сможем.

### Собственно, оперативка

__Оперативная память__ представляет из себя просто большое количество тех самых ячеек памяти, объединенных в 
байты. Каждый байт имеет свой номер, начиная с нуля. То есть при необходимости мы можем положить какую-то 
информацию в байт под номером, например, 1337 или любой другой, не занятый другими данными. 

В введении было упомянуто еще одно сложное слово - __переменная__. Разберемся и с этой хуйней. Когда мы пишем 
строку навроде `int x = 0`, в оперативной памяти выделяется 4 байта, а адрес этих четырех байтов запоминается. 
Теперь, когда мы напишем `x = 83`, новое число положится в те же ячейки оперативной памяти. 

То есть по сути, объявляя переменные, мы избавляем себя от геморроя по поиску, куда же положить данные, чтобы 
потом их оттуда достать. 

### Типы данных в C

Перейдем к более содержательной части. В C не то чтобы много типов данных, но все они имеют до жопы разных 
модификаций и прочей шелухи.

В первую очередь - целые числа. В подавляющем большинстве языков обозначаемые словом `int`. Однако помимо слова 
`int` можно вдогонку докинуть слова `signed`, `unsigned`, `short`, `long`, `long long` и различные их комбинации. 
Они влияют на количество байт, выделяемых под переменную (как следствие и на порядок чисел, которые можно в эту 
переменную вхуярить). 

Другой тип - `char`, по природе своей тоже является целым числом, но несет в себе глубинный смысл - такое число 
обозначает номер букавы, согласно таблице ASCII. 

![Sample text](pictures/types_1.png "Собственно, ASCII таблица")

В целом такой тип тоже можно до кучи обложить непотребствами типа `signed` или `unsigned`, но на деле такой 
онанизм редко когда бывает нужен. 

Далее идет тип `float` и его злой старший брат `double`, представляющий собой более жирный и точный `float`. 
Оба типа хранят в себе число с плавающей точкой в экспоненциальном виде. Для тех, кто в танке, это такие чиселки 
с точечкой aka десятичные дроби. Что характерно и уже становится традицией, способен разжиряться дополнительным 
`long`. 

Особняком стоит тип `bool`, он среди них новенький (введен в стандарт только в 99-м году). Предназначен для 
хранения логических значений (`true` или `false`), хоть и являет собой все тот же `int`, но поменьше. 

Так же есть типы `memsize` (навроде `size_t`), те же инты, только в профиль. Они нам пока неинтересны и 
рассматривать их мы не будем.

Ну и напоследок существует тип `void`, представляющий собой хуй пойми чего, отсутствие чего либо и вообще 
прекрасен и ужасен в своей абстрактности и деструктивном влиянии на неокрепшие умы. 

Указатели и структуры тоже можно рассмотреть, но делать мы этого не будем до поры до времени. 

В целом про все эти типы данных можно почитать подробнее, обладая минимальной способностью гуглить. 

### А че со строками? 

А ниче. В C строк как таковых нет, используются массивы отдельных символов (`char`). Про массивы речь будет 
также идти в дальнейшем. Обычно именно на моменте работы со строками происходит отсев недостаточно ебанутых 
с последующим переходом их на Python, C++ и другие языки, более дружелюбные к юзверю. 

![Sample text](memes/types_2.png "Да.") 

Несмотря на одиозность работы со строками в C, все не настолько плохо и при должной сноровке это возможно без 
особых трудностей и боли. Тем более в стандартном комплекте есть библиотека `string.h`, позволяющая упростить 
работу со строками. 

## Finally

Можно много чего еще говорить про типы, их преобразования, но делать это впадлу, да и не нужно пока. В 
дальнейшем все это будет подробно рассмотрено.

Ну и конечно же, хотелось бы получить фидбэк в виде комментов, чтобы понимать, в каком направлении задвигать 
дальнейший контент и нужно ли пояснять какие-то моменты из уже упомянутых. Возможно я даже к нему прислушаюсь.
