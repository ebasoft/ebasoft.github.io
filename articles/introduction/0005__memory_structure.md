# Организация памяти
> [Пацанская прога](https://t.me/+osWqEEfNA5Y2ZWYy), 24 февраля 2024

В предыдущей статье я мощнейше развалил адресную арифметику, сейчас мощнейше 
поясню, как устроена и используется оперативка в компах. Начну немного 
издалека - с ELF-файлов. Сначала мб покажется что все что здесь говорится - 
бессвязный бред сумашедшего, но ближе к концу все сюжетные ветки сойдутся в 
одну. 

## ELF-файл

Если хорошенько подумать, можно вспомнить, как в самой первой статье я накинул 
на вентилятор понятие "компиляция". По сути своей компиляция - это перевод 
программы из высокоуровневого языка в совсем низкоуровневые машинные коды, а 
заодно оптимизация и адаптация программы под целевую платформу (например под 
вашу машину с Core i7 9-го поколения на борту). Процесс компиляции - вещь вообще 
очень сложная и многогранная, в подробностях он будет рассмотрен позднее. Сейчас 
лишь кратко на аналогии поясню кто такая эта ваша компиляция и что она примерно
делает. 

Представим пример - вам необходимо объяснить кому-либо, как дойти до 
вытрезвителя. В случае, если этот кто-то - обычный человек, вы можете объяснить
маршрут "высокоуровневым языком". Однако если вы говорите со слепым инвалидом 
умственного труда, к тому же без рук и одной ноги, вам придется изрядно 
изъебнуться, чтобы случайно не отправить его в свободное плавание по близлежащей
реке. Вот как раз процесс преобразования человеческого объяснение в объяснение 
для инвалидов и назвается компиляцией (дада, я так незаметно назвал процессор 
инвалидом, это неспроста).

Итак, вот объяснение на человеческом языке

```c
пока (не дойдедешь до перекрестка)              
    иди(прямо);

поверни(налево);
иди(нахуй);
```

Посмотрим, во что оно превратиться после импровизированной "компиляции"

```c
подними левую ногу
подвинь левую ногу вперед
опусти левую ногу
подними правую ногу
подвинь правую ногу вперед
опусти правую ногу
посмотри, не перекресток ли впереди
если нет, то иди к первой инструкции
........
```

Ну и так далее. В целом, думаю, понятно, что конкретно делает компиляция. 

Возникает вопрос интимного характера - а как хранить скомпилированную программу?
Вопрос этот весьма важен, потому что компиляция в общем случае - процесс не 
быстрый. Так, возникает необходимость хранить уже скомпилированную программу, 
чтобы при необходимости ее можно было просто запустить. 

Именно для этой цели и нужны **ELF-файлы**. В них хранится заранее 
скомпилированный код, который можно не отходя от кассы запустить на платформе,
под которую он был скомпилирован. Если вы убежденный адепт _форточек_, 
~~соболезную~~ вы должны быть знакомы с форматом `.exe`, который по сути своей
предназначен для этих же целей. Этот формат несколько отличается от ELF, при 
необходимости можно будет изучить его подробнее.

Ну такой вот примерно рецепт ELF-файла усредненный, потому что вариаций масса. 
Внутрь запаковываются скомпилированные инструкции, которые сможет исполнить 
процессор, значения констант, начальные значения глобальных переменных и т.д. 
Все это жарится до дыма. При этом стоит отметить, что всякое говно, которое 
нужно напихать в этот файл, разделяется на "секции". Например, в секцию `.text` 
укладываются байты исполняемого кода, а в секцию `.rodata` кладутся константы 
(`ro` в этом случае значит, _неожиданно_, `readonly`). Надо ли говорить говорить
о том, какой дичайший сегфолт потом? Дампы такие, что операционка от процессора 
отклеивается.

К каждой секции генерируется заголовок, в котором описывается, что это за 
секция, какой она длины, с какого байта в файле она начинается и так далее. 

В дальнейшем, когда мы пытаемся запустить такую программу, упакованную в 
ELF-файл, операционка в первую очередь читает заголовки и пытается понять, как и 
что нужно сделать с файлом, чтобы содержащаяся в нем программа запустилась. 
Далее ОС читает байты каждой из секций и укладывает их в оперативную память без
изменений (по сути просто берем все байты из секции `.text` и тупо копируем в 
оперативку). Собственно, после этого этапа можно просто поставить **IP** 
(**I**nstruction **P**ointer) на первый исполняемый байт и просто начать 
поочередно исполнять инструкции, расположенные далее.

Здесь же можно сразу понять, кто такой этот ваш `SIGSEGV`. Это т.н. сигнал 
ошибки сегментации (Segmentation Fault). Он возникает в случае, если программа 
пытается лезть куда-то в память, где ей быть не полагается. Например, если мы 
пытаемся изменить какой-то байт секции `.text` (она по спецификации доступна 
только на чтение), то система бьет нас по рукам, прибивает нашу программу и в 
некоторых случаях падает сама, жидко пропускаясь в штаны. 

## Стэк

Дабы не травмировать нежный мозг читателя, воспользуемся упрощенной моделью 
оперативки и не будем вдаваться в подробности ~~постироничной~~ постраничной 
памяти и прочих тонкостей. Допустим, мы уже выгрузили исполняемый ELF-файл в 
память и в целом готовы начать его исполнять. Отлично, а что делать с 
переменными? В первом приближении можно реализовать трюк, задействующий палец и 
кольцевую мышцу выхода прямой кишки, выделив место под переменную прямо в коде. 
Каким образом? Допустим, у нас имеется сферическая функция в вакууме, считающая 
число Фибоначчи с номером `n`.

> Для людей, задвинувших матешу в пердак, поясню, что это последовательность 
> чисел, в которой каждое следующее число является суммой двух предыдущих. 
> Иными словами 
$$
\begin{cases}
    x_n = x_{n-1} + x_{n-2};\\
    x_0 = 0;\\
    x_1 = 1.
\end{cases}
$$

Итак, сам сабж

```c
int get_fib(const int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;
    int prev1 = get_fib(n-1);
    int prev2 = get_fib(n-2);
    int next = prev1 + prev2;
    return next;
}
```

Очевидно, это не лучший способ написать такую функцию, да и алгоритмическая 
сложность у него конская (навскидку насчитал $O(2^{n \log{n}})$, в то время как 
у чуть менее изящного перебора циклом сложность уже линейная). Однако на таком 
примере будет проще всего пояснять за базар.

Итак, допустим, мы отключили вообще все оптимизации и компилятор не стал 
выпиливать переменные. Тогда в рамках данной функции у нас создается три 
переменные - `prev1`, `prev2` и `next`. "Выделим" под них место прямо в коде. 
Грубо говоря, вначале будут идти несколько исполняемых инструкций, а затем 
пустое место размером в 12 байт. Задаемся закономерным вопросом - а че, так 
нельзя было? Если исключить ньюанс с `W^X` (кампухтор любезно откажется 
записывать что-либо в часть оперативки, где лежат инструкции и наоборот), 
остается еще один способ выстрелить себе в ногу. И это рекурсия.

Если внимательно рассмотреть приведенный фрагмент кода, можно заметить, что 
функция `get_fib` вызывает функцию `get_fib` и функцию `get_fib`. Это абсолютно 
каноничный пример рекурсии. [мб картинку вставить]. Однако, опять есть нюанс. 
Функция в оперативке лежит только одна, а при вызове ее самой из нее же, 
процессор просто прыгает на начало этой функции, запоминая, откуда он прыгнул. 
То есть по факту, если на первой итерации этого цирка записать в эти переменные 
какие-либо значения, то при следующей итерации старые значения будут потерты к 
чертовой матери. Соответственно, при возврате из вложенного вызова невозможно 
будет восстановить предыдущие значения, которые лежали в этих переменных. Решают 
эту дилему чуть более хитрым способом хранения переменных - стэком.

Итак, стэк в общечеловеческом понимании - это структура типа **LIFO** (Last In 
First Out), которая по принципу похожа на тубус с таблетками ~~от поноса~~ - 
можно в нее добавлять что-либо и вытаскивать, при этом вытаскиваетая строго 
последний элемент этой структуры. Обычно со стэком работают через методы `push` 
и `pop`, позволяющие в него что-либо запихнуть и из него что-либо вытащить. В 
процессорном переложении стэк несколько более извращенный, хоть по принципу и 
схожий с этой попсовой структуркой. Итак, сведем идеи воедино. Имея регистры RSP 
(Stack Pointer) и RBP (Base Pointer), и шмат свободной оперативной памяти, можно 
организовать хранение переменных в стэке (причем это разом решит проблему 
рекурсии любой сложности). 

Рецепт следующий:

1) При вызове какого-либо метода, на стэк кладется адрес, с которого происходит 
вызов (при этом значение регистра RSP уменьшается, так как в стэк было добавлено 
что-то новое)
3) После того, как был совершен переход на новый адрес, в стэк укладывается 
текущее значение RBP (позже будет понятно, что это такое и нахера)
5) В RBP кладется текущее значение RSP, то есть по сути адрес, с которого 
начинаются все локальные переменные в рамках работы этой функции
7) Для каждой переменной выделяется необходимое количество памяти, а значение 
RSP уменьшается на общий размер всех локальных переменных

Таким образом получается, что (в упрощении, естественно), написав `*(rbp - 8)` 
мы обратимся к первой переменной функции, `*(rbp - 16)` - ко второй. При этом 
при вызове какой либо функции никакая информация не потеряется, а старые 
значения регистров будут сохранены в стэке. Таким образом после выхода из 
вызванной функции можно будет одним махом восстановить все и продолжить 
выполнять функцию как ни в чем не бывало. Рецепт восстановления предельно прост: 

1) Выставляем RSP равным RBP (то есть по сути убираем из стэка все локальные 
переменные)
2) Выкладываем в RBP его старое значение, которое было убрано на стэк при вызове
3) Возвращаемся по адресу, с котрого был произведен вызов

При этом для вызывающей стороны все будет выглядеть так, будто никто ничего и 
не вызывал, то есть работа будет продолжена с той же точки, что и до вызова. 
Кусок стэка, в котором лежит адрес возврата, старое значение RBP и весь 
локальный хлам, называется стэковым фреймом функции. Собственно на картинке 
ниже показано что происходит при вызове новой функции.

[картинка про стековый фрейм]

Очевидно также, что на стэке можно уложить и что-то более жирное, чем просто 
пару переменных. Например, можно спокойно выделить место под массив (причем даже 
неизвестного на момент компиляции размера). Однако встает вопрос - что делать, 
если нужно создать переменную или массив и пользоваться ей/им в разных функциях? 
Очевидно, все что было выделено на стеке, после возврата из функции будет 
нещадно перетерто стековым фреймом новой функции. Решение есть и оно приносит 
боль и ~~SIGSEGV~~ всем и каждому. Встречайте,

## Куча

Можно сколь угодно долго шутить про название этой сущности, но пахнуть приятнее 
она не станет. В целом, куча - это динамическая память. Место в ней можно 
выделять и освобождать вручную (в случае C/C++) или автоматически (другие 
б-гмерзкие языки). Основная суть остается неизменной - при запуске программы нам 
выделяется определенный объем памяти _на всякий случай_. Данные о том, что, где 
и сколько выделено места в этой памяти, лежит в структуре, называемой кучей. 

Перейдем от слов к делу - в великом и могучем для выделения динамической памяти 
есть функции-братья `alloc`, `malloc` и `calloc`, а для освобождения - `free`. 
Каждая из функций выделения памяти по сути делает одно и то же - идет к 
системному аллокатору памяти и просит у него N байт в куче. Аллокатор в свою 
очередь, если может найти столько байт свободного места, записывает себе в 
блокнотик что с такого по такой адрес память занята, а запрашивающему возвращает 
адрес начала выделенного пространства. Далее мы этим адресом можем жонглировать 
как хотим - писать туда, читать, передавать куда угодно и сколько угодно раз. 
Однако по завершении работы с этой памятью, когда она уже **совсем** не нужна, 
нужно ее вручную высвободить, то есть сказать системному аллокатору, что эта 
память больше использоваться не будет и ее можно использовать под что-то новое. 
Именно для этого нужна функция `free`.

Несмотря на общую простоту механизма, обычно он вызывает наибольшее количество 
страданий у юзера. Вектора выстрела в ногу у этого механизма примерно следующие:

1) Утечка памяти. Имаджинируем ситуацию, что юзеру понадобилось выделить целый 
гигабайт памяти под массив его бесполезных циферок типа `int`. Соответственно, 
он будет для этого использовать код следующего толка: 
`void* unums = calloc(268435456, sizeof(int));`. Данный шмат кода запросит у 
аллокатора \[268435456 \cdot sizeof(int) = 268435456 \cdot 4 = 1 \text{ Гб}\] 
места в куче. При это единственным опознавательным знаком этого пространства 
будет адрес, лежащий в переменной `unums`. Если после окончания работы с этим 
массивом будет возврат из функции, в которой мы этот адрес запросили, то само 
знаечние адреса будет перетерто новым стэковым фреймом. При этом аллокатор будет 
уверен, что этот пресловутый гигабайт еще нужен и никому это пространство 
отдавать не будет, а освободить его уже не получится, так как адрес был перетерт 
чем-то левым. Мораль такова - выделил память - изволь очистить не отходя от 
кассы, а то ноги оторвет.
2) Проблема вторая - двойное освобождение. Настрадавшись с утечками памяти 
человек обычно переходит на следующую стадию и начинает дотошнейшим образом 
очищать за собой динамическую память, что иногда приводит к не менее 
разрушительным последствиям. Так, если выделенную память почистить дважды, то 
есть риск схлопотать по ебалу ошибку `double free`. То есть мало того, что 
нужно вовремя освобождать память, так еще и делать это с толком и расстановкой.
3) В целом использование динамической памяти является источником наибольшего 
количества ошибок по типу сегфолта. Связано это с тем, что выход за пределы 
массива не всегда автоматом детектится (можно конечно использовать санитайзеры, 
которые дотошно проверят все и вся, но это не всегда возможно/опрадано). Можно 
встретить прекрасные образчики, когда на одних данных код работает стабильно и 
хорошо, в то время как на других сыплется в рандомном месте. При этом истинная 
причина ошибки - выход за пределы массива в третьем месте. Опять же, 
санитайзеры + валгринд в целом могут отловить такие ошибки.


По итогам стоит сказать, что каждый метод хранения информации в оперативке стоит
использовать строго с умом. Ибо выделять на куче место под массив, который так 
никуда и не уедет, крайне глупо. Динамическая память в целом это золотой топор - 
вроде блестит, но на ногу упадет крайне болезненно.
